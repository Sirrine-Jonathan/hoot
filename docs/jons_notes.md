'\n\t\t\t\tYour First Extension\nIn this topic, we\'ll teach you the fundamental concepts for building extensions. Make sure you have Node.js and Git installed.\nFirst, use Yeoman and VS Code Extension Generator to scaffold a TypeScript or JavaScript project ready for development.\n\n\nIf you do not want to install Yeoman for later use, run the following command:\nBashnpx --package yo --package generator-code -- yo code\n\n\n\nIf you instead want to install Yeoman globally to ease running it repeatedly, run the following command:\nBashnpm install --global yo generator-code\n\nyo code\n\n\n\nFor a TypeScript project, fill out the following fields:\nBash# ? What type of extension do you want to create? New Extension (TypeScript)\n# ? What\'s the name of your extension? HelloWorld\n### Press <Enter> to choose default for all options below ###\n\n# ? What\'s the identifier of your extension? helloworld\n# ? What\'s the description of your extension? LEAVE BLANK\n# ? Initialize a git repository? Y\n# ? Which bundler to use? unbundled\n# ? Which package manager to use? npm\n\n# ? Do you want to open the new folder with Visual Studio Code? Open with `code`\n\n\nInside the editor, open src/extension.ts and press F5 or run the command Debug: Start Debugging from the Command Palette (Ctrl+Shift+P). This will compile and run the extension in a new Extension Development Host window.\nRun the Hello World command from the Command Palette (Ctrl+Shift+P) in the new window:\n\n \n\nYou should see the Hello World from HelloWorld! notification showing up. Success!\nIf you aren\'t able to see the Hello World command in the debug window, check the package.json file and make sure that engines.vscode version is compatible with the installed version of VS Code.\nDeveloping the extension\nLet\'s make a change to the message:\n\nChange the message from "Hello World from HelloWorld!" to "Hello VS Code" in extension.ts.\nRun Developer: Reload Window in the new window.\nRun the command Hello World again.\n\nYou should see the updated message showing up.\n\n \n\nHere are some ideas for things for you to try:\n\nGive the Hello World command a new name in the Command Palette.\nContribute another command that displays current time in an information message. Contribution points are static declarations you make in the package.json Extension Manifest to extend VS Code, such as adding commands, menus, or keybindings to your extension.\nReplace the vscode.window.showInformationMessage with another VS Code API call to show a warning message.\n\nDebugging the extension\nVS Code\'s built-in debugging functionality makes it easy to debug extensions. Set a breakpoint by clicking the gutter next to a line, and VS Code will hit the breakpoint. You can hover over variables in the editor or use the Run and Debug view in the left to check a variable\'s value. The Debug Console allows you to evaluate expressions.\n\n \n\nYou can learn more about debugging Node.js apps in VS Code in the Node.js Debugging Topic.\nNext steps\nIn the next topic, Extension Anatomy, we\'ll take a closer look at the source code of the Hello World sample and explain key concepts.\nYou can find the source code of this tutorial at: https://github.com/microsoft/vscode-extension-samples/tree/main/helloworld-sample. The Extension Guides topic contains other samples, each illustrating a different VS Code API or Contribution Point, and following the recommendations in our UX Guidelines.\nUsing JavaScript\nIn this guide, we mainly describe how to develop VS Code extension with TypeScript because we believe TypeScript offers the best experience for developing VS Code extensions. However, if you prefer JavaScript, you can still follow along using helloworld-minimal-sample.\nUX Guidelines\nThis is also a good time to review our UX Guidelines so you can start designing your extension user interface to follow the VS Code best practices.\n\n\t\t\t\tHelp and supportWas this documentation helpful?Yes , this page was helpfulNo , this page was not helpfulStill need help?Ask the communityRequest featuresReport issuesHelp us improveAll VS Code docs are open source. See something that\'s wrong or unclear? Submit a pull request.\n\t\t\t\t\n\t\t\t\t02/04/2026\n\t\t\t\t\n

`\n\t\t\t\tExtension Anatomy\nIn the last topic, you were able to get a basic extension running. How does it work under the hood?\nThe Hello World extension does 3 things:\n\nRegisters the onCommand Activation Event: onCommand:helloworld.helloWorld, so the extension becomes activated when user runs the Hello World command.Note: Starting with VS Code 1.74.0, commands declared in the commands section of package.json automatically activate the extension when invoked, without requiring an explicit onCommand entry in activationEvents.\n\nUses the contributes.commands Contribution Point to make the command Hello World available in the Command Palette, and bind it to a command ID helloworld.helloWorld.\nUses the commands.registerCommand VS Code API to bind a function to the registered command ID helloworld.helloWorld.\n\nUnderstanding these three concepts is crucial to writing extensions in VS Code:\n\nActivation Events: events upon which your extension becomes active.\nContribution Points: static declarations that you make in the package.json Extension Manifest to extend VS Code.\nVS Code API: a set of JavaScript APIs that you can invoke in your extension code.\n\nIn general, your extension would use a combination of Contribution Points and VS Code API to extend VS Code's functionality. The Extension Capabilities Overview topic helps you find the right Contribution Point and VS Code API for your extension.\nLet's take a closer look at Hello World sample's source code and see how these concepts apply to it.\nExtension File Structure\nText.\n├── .vscode\n│ ├── launch.json // Config for launching and debugging the extension\n│ └── tasks.json // Config for build task that compiles TypeScript\n├── .gitignore // Ignore build output and node_modules\n├── README.md // Readable description of your extension's functionality\n├── src\n│ └── extension.ts // Extension source code\n├── package.json // Extension manifest\n├── tsconfig.json // TypeScript configuration\n\nYou can read more about the configuration files:\n\nlaunch.json used to configure VS Code Debugging\ntasks.json for defining VS Code Tasks\ntsconfig.json consult the TypeScript Handbook\n\nHowever, let's focus on package.json and extension.ts, which are essential to understanding the Hello World extension.\nExtension Manifest\nEach VS Code extension must have a package.json as its Extension Manifest. The package.json contains a mix of Node.js fields such as scripts and devDependencies and VS Code specific fields such as publisher, activationEvents and contributes. You can find descriptions of all VS Code specific fields in Extension Manifest Reference. Here are some most important fields:\n\nname and publisher: VS Code uses <publisher>.<name> as a unique ID for the extension. For example, the Hello World sample has the ID vscode-samples.helloworld-sample. VS Code uses the ID to uniquely identify your extension.\nmain: The extension entry point.\nactivationEvents and contributes: Activation Events and Contribution Points.\nengines.vscode: This specifies the minimum version of VS Code API that the extension depends on.\n\nJSON{\n "name": "helloworld-sample",\n "displayName": "helloworld-sample",\n "description": "HelloWorld example for VS Code",\n "version": "0.0.1",\n "publisher": "vscode-samples",\n "repository": "https://github.com/microsoft/vscode-extension-samples/helloworld-sample",\n "engines": {\n "vscode": "^1.51.0"\n },\n "categories": ["Other"],\n "activationEvents": [],\n "main": "./out/extension.js",\n "contributes": {\n "commands": [\n {\n "command": "helloworld.helloWorld",\n "title": "Hello World"\n }\n ]\n },\n "scripts": {\n "vscode:prepublish": "npm run compile",\n "compile": "tsc -p ./",\n "watch": "tsc -watch -p ./"\n },\n "devDependencies": {\n "@types/node": "^8.10.25",\n "@types/vscode": "^1.51.0",\n "tslint": "^5.16.0",\n "typescript": "^3.4.5"\n }\n}\n\nNote: If your extension targets a VS Code version prior to 1.74, you must explicitly list onCommand:helloworld.helloWorld in activationEvents.\nExtension Entry File\nThe extension entry file exports two functions, activate and deactivate. activate is executed when your registered Activation Event happens. deactivate gives you a chance to clean up before your extension becomes deactivated. For many extensions, explicit cleanup may not be required, and the deactivate method can be removed. However, if an extension needs to perform an operation when VS Code is shutting down or the extension is disabled or uninstalled, this is the method to do so.\nThe VS Code extension API is declared in the @types/vscode type definitions. The version of the vscode type definitions is controlled by the value in the engines.vscode field in package.json. The vscode types give you IntelliSense, Go to Definition, and other TypeScript language features in your code.\nTypeScript// The module 'vscode' contains the VS Code extensibility API\n// Import the module and reference it with the alias vscode in your code below\nimport \* as vscode from 'vscode';\n\n// this method is called when your extension is activated\n// your extension is activated the very first time the command is executed\nexport function activate(context: vscode.ExtensionContext) {\n // Use the console to output diagnostic information (console.log) and errors (console.error)\n // This line of code will only be executed once when your extension is activated\n console.log('Congratulations, your extension "helloworld-sample" is now active!');\n\n // The command has been defined in the package.json file\n // Now provide the implementation of the command with registerCommand\n // The commandId parameter must match the command field in package.json\n let disposable = vscode.commands.registerCommand('helloworld.helloWorld', () => {\n // The code you place here will be executed every time your command is executed\n\n // Display a message box to the user\n vscode.window.showInformationMessage('Hello World!');\n });\n\n context.subscriptions.push(disposable);\n}\n\n// this method is called when your extension is deactivated\nexport function deactivate() {}\n\n\n\t\t\t\tHelp and supportWas this documentation helpful?Yes , this page was helpfulNo , this page was not helpfulStill need help?Ask the communityRequest featuresReport issuesHelp us improveAll VS Code docs are open source. See something that's wrong or unclear? Submit a pull request.\n\t\t\t\t\n\t\t\t\t02/04/2026\n\t\t\t\t\n

"\n\t\t\t\tExtension Capabilities Overview\nVisual Studio Code offers many ways for extensions to extend its capabilities. It can sometimes be hard to find the right Contribution Points and VS Code API to use. This topic splits extension capabilities into a few categories. Each category describes:\n\nSome functionalities your extension could use\nLinks to more detailed topics for using these functionalities\nA few extension ideas\n\nHowever, we also impose restrictions upon extensions to ensure the stability and performance of VS Code. For example, extensions cannot access the DOM of VS Code UI.\nCommon Capabilities\nCommon Capabilities are core pieces of functionality that you can use in any extension.\nSome of these capabilities include:\n\nRegistering commands, configurations, keybindings, or context menu items.\nStoring workspace or global data.\nDisplaying notification messages.\nUsing Quick Pick to collect user input.\nOpen the system file picker to let users select files or folders.\nUse the Progress API to indicate long-running operations.\n\nTheming\nTheming controls the look of VS Code, both the colors of source code in the editor and the colors of the VS Code UI. If you've ever wanted to make it look like you're coding the Matrix by making VS Code different shades of green, or just wanted to create the ultimate, minimalist grayscale workspace, then themes are for you.\nExtension Ideas\n\nChange colors of your source code.\nChange colors of the VS Code UI.\nPort an existing TextMate theme to VS Code.\nAdd custom file icons.\n\nDeclarative Language Features\nDeclarative Language Features adds basic text editing support for a programming language such as bracket matching, auto-indentation and syntax highlighting. This is done declaratively, without writing any code. For more advanced language features, like IntelliSense or debugging, see Programmatic Language Features.\nExtension Ideas\n\nBundle common JavaScript snippets into an extension.\nTell VS Code about a new programming language.\nAdd or replace the grammar for a programming language.\nExtend an existing grammar with grammar injections.\nPort an existing TextMate grammar to VS Code.\n\nProgrammatic Language Features\nProgrammatic Language Features add rich programming language support such as Hovers, Go to Definition, diagnostic errors, IntelliSense and CodeLens. These language features are exposed through the vscode.languages.\* API. An extension can either use these APIs directly, or write a Language Server and adapt it to VS Code using the VS Code Language Server library.\nAlthough we provide a listing of language features and their intended usage, nothing prevents you from using these API creatively. For example, CodeLens and Hovers are a great way to present additional information inline, while diagnostic errors can be used to highlight spelling or code style errors.\nExtension Ideas\n\nAdd hovers that show sample usage of an API.\nReport spelling or linter errors in source code using diagnostics.\nRegister a new code formatter for HTML.\nProvide rich, context-aware IntelliSense.\nAdd folding, breadcrumbs and outline support for a language.\n\nWorkbench Extensions\nWorkbench Extensions extend the VS Code Workbench UI. Add new right-click actions to the File Explorer, or even build a custom explorer using VS Code's TreeView API. And if your extension needs a fully customized user interface, use the Webview API to build your own document preview or UI using standard HTML, CSS, and JavaScript.\nExtension Ideas\n\nAdd custom context menu actions to the File Explorer.\nCreate a new, interactive TreeView in the Side Bar.\nDefine a new Activity Bar view.\nShow new information in the Status Bar.\nRender custom content using the WebView API.\nContribute Source Control providers.\n\nDebugging\nYou can take advantage of VS Code's Debugging functionality by writing Debugger Extensions that connect VS Code's debugging UI to a specific debugger or runtime.\nExtension Ideas\n\nConnect VS Code's debugging UI to a debugger or runtime by contributing a Debug Adapter implementation.\nSpecify the languages supported by a debugger extension.\nProvide rich IntelliSense and hover information for the debug configuration attributes used by the debugger.\nProvide debug configuration snippets.\n\nOn the other hand, VS Code also offers a set of Debug Extension API, with which you can implement debug-related functionality on top of any VS Code debugger, in order to automate users' debugging experience.\nExtension Ideas\n\nStart debug sessions based on dynamically created debug configurations.\nTrack the lifecycle of debug sessions.\nCreate and manage breakpoints programmatically.\n\n\n\nUX Guidelines\nTo help make your extension fit seamlessly into the VS Code user interface, refer to the UX Guidelines, where you'll learn the best practices for creating extension UI and conventions for following the preferred VS Code workflows.\nRestrictions\nThere are certain restrictions we impose upon extensions. Here are the restrictions and their purposes.\nNo DOM Access\nExtensions have no access to the DOM of VS Code UI. You cannot write an extension that applies custom CSS to VS Code or adds an HTML element to VS Code UI.\nAt VS Code, we're continually trying to optimize use of the underlying web technologies to deliver an always available, highly responsive editor and we will continue to tune our use of the DOM as these technologies and our product evolve. To ensure that extensions cannot interfere with the stability and performance of VS Code, and that we can continue to improve the DOM of VS Code without breaking existing extensions, we run extensions in an Extension Host process and prevent direct access to the DOM.\nNo custom style sheets\nA custom style sheet provided by users or extensions would work against the DOM structure and class names. These are not documented as we consider them internal. To evolve, refactor, or improve VS Code, we need the freedom to make changes to the user interface. Any change to the DOM can break existing custom style sheets, resulting in frustration for style sheet providers and a bad user experience with UI glitches coming from the broken style sheet.\nInstead, VS Code aims to provide a well-designed extension API supporting UI customizations. The API is documented, comes with tooling and samples, and is kept stable across all upcoming releases of VS Code.\n\n\t\t\t\tHelp and supportWas this documentation helpful?Yes , this page was helpfulNo , this page was not helpfulStill need help?Ask the communityRequest featuresReport issuesHelp us improveAll VS Code docs are open source. See something that's wrong or unclear? Submit a pull request.\n\t\t\t\t\n\t\t\t\t02/04/2026\n\t\t\t\t\n

`\n\t\t\t\tExtending Workbench\n"Workbench" refers to the overall Visual Studio Code UI that encompasses the following UI components:\n\nTitle Bar\nActivity Bar\nSide Bar\nPanel\nEditor Group\nStatus Bar\n\nVS Code provides various APIs that allow you to add your own components to the Workbench. For example, in the image below:\n\n\nActivity Bar: The Azure App Service extension adds a View Container\nSide Bar: The built-in NPM extension adds a Tree View to the Explorer View\nEditor Group: The built-in Markdown extension adds a Webview next to other editors in the Editor Group\nStatus Bar: The VSCodeVim extension adds a Status Bar Item in the Status Bar\n\nViews Container\nWith the contributes.viewsContainers Contribution Point, you can add new Views Containers that display next to the five built-in Views Containers. Learn more at the Tree View topic.\nTree View\nWith the contributes.views Contribution Point, you can add new Views that display in any of the View Containers. Learn more at the Tree View topic.\nWebview\nWebviews are highly customizable views built with HTML/CSS/JavaScript. They display next to text editors in the Editor Group areas. Read more about Webview in the Webview guide.\nStatus Bar Item\nExtensions can create custom StatusBarItem that display in the Status Bar. Status Bar Items can show text and icons and run commands on click events.\n\nShow text and icons\nRun a command on click\n\nYou can learn more by reviewing the Status Bar extension sample.\n\n\t\t\t\tHelp and supportWas this documentation helpful?Yes , this page was helpfulNo , this page was not helpfulStill need help?Ask the communityRequest featuresReport issuesHelp us improveAll VS Code docs are open source. See something that's wrong or unclear? Submit a pull request.\n\t\t\t\t\n\t\t\t\t02/04/2026\n\t\t\t\t\n
